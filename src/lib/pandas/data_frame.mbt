///|
struct DataFrame {
  mut data : Array[Series]
  mut shape : Array[Int]
  index : Map[String, Int]
} derive(Eq)

///|
pub impl Hash for DataFrame with hash_combine(self, hasher) {
  for idx in self.index {
    hasher.combine(idx.0)
    hasher.combine(idx.1)
    for col in self.data {
      hasher.combine(col)
    }
  }
}

///|
let emptyDataFrame : DataFrame = DataFrame::{
  data: [],
  shape: [0, 0],
  index: {},
}

///| Create a new DataFrame
///
/// ### Parameters
///
/// - `data` : Array of Series
///
/// ### Return
///
/// - `DataFrame!InconsistentSeriesLength` : A new DataFrame instance
///
/// ### Errors
///
/// - `InconsistentSeriesLength` : Raised if the lengths of the Series are not equal
///
/// ### Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesInput::Int32([1, 2, 3])),
///   Series::new("B", SeriesInput::Float32([1.5, 2.0, 2.5])),
///   Series::new("C", SeriesInput::Bool([true, false, true])),
///   Series::new("D", SeriesInput::Str(["a", "b", "c"])),
///   Series::new("E", SeriesInput::Int32_Nullable([Some(1), None, Some(3)])),
/// ])
/// ```
pub fn DataFrame::new(
  data : Array[Series]
) -> DataFrame raise InconsistentSeriesLength {
  let index : Map[String, Int] = {}
  for i = 0; i < data.length(); i = i + 1 {
    if data[i].data().length() != data[0].data().length() {
      raise InconsistentSeriesLength(
        "Could not create a new DataFrame. The Series lengths are not equal.",
      )
    }
    index[data[i].name()] = i
  }
  DataFrame::{ data, shape: [data[0].data().length(), data.length()], index }
}

///|
pub fn DataFrame::shape(self : DataFrame) -> Array[Int] {
  self.shape
}

///|
pub fn DataFrame::data(self : DataFrame) -> Array[Series] {
  self.data
}

///| Trait Show for DataFrame
pub impl Show for DataFrame with output(self, logger) {
  let mut row_str = "\t"
  for col in self.data {
    row_str = row_str + col.name() + "\t"
  }
  logger.write_string(row_str + "\n")
  row_str = ""
  for i = 0; i < self.shape[0]; i = i + 1 {
    row_str += i.to_string() + "\t"
    for col in self.data {
      match col.bitmap[i] {
        true => row_str += "null\t"
        false =>
          match col.data() {
            SeriesData::Int(vals) => row_str += vals[i].to_string() + "\t"
            SeriesData::Float(vals) => row_str += vals[i].to_string() + "\t"
            SeriesData::Bool(vals) => row_str += vals[i].to_string() + "\t"
            SeriesData::Str(vals) => row_str += vals[i] + "\t"
          }
      }
    }
    row_str += "\n"
  }
  logger.write_string(row_str)
}

///| Display the first few rows of the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `num` : The number of rows to display (default is 5)
///
/// ### Return
///
/// - `Unit` : This function prints the first few rows of the DataFrame
///
/// ### Example
/// ```
/// df.head()
/// df.head(rows=3)
/// ```
pub fn DataFrame::head(self : DataFrame, rows~ : Int = 5) -> Unit {
  let mut row_str = "\t"
  for col in self.data {
    row_str = row_str + col.name() + "\t"
  }
  row_str += "\n"
  for i = 0; i < @math.minimum(rows, self.shape[0]); i = i + 1 {
    row_str += i.to_string() + "\t"
    for col in self.data {
      match col.bitmap[i] {
        true => row_str += "null\t"
        false =>
          match col.data() {
            SeriesData::Int(vals) => row_str += vals[i].to_string() + "\t"
            SeriesData::Float(vals) => row_str += vals[i].to_string() + "\t"
            SeriesData::Bool(vals) => row_str += vals[i].to_string() + "\t"
            SeriesData::Str(vals) => row_str += vals[i] + "\t"
          }
      }
    }
    row_str += "\n"
  }
  println(row_str)
}

///| Add a new column to the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `col` : The Series to be added as a new column
///
/// ### Return
///
/// - `Unit!` : This function adds a new column to the DataFrame or raises an error
///
/// ### Errors
///
/// - `InconsistentSeriesLength`: Series length is not equal to the DataFrame length
/// - `DuplicateColumnError`: Series name already exists
///
/// ### Example
/// ```
/// let new_column = Series::new("B", SeriesInput::Int32([1, 2, 3]))
/// df.add_column(new_column)
/// ```
pub fn DataFrame::add_column(self : DataFrame, col : Series) -> Unit raise{
  guard col.data.length() == self.shape[0] else {
    raise InconsistentSeriesLength(
      "Could not add a new column to the DataFrame. The Series lengths are not equal.",
    )
  }
  guard not(self.index.contains(col.name)) else {
    raise DuplicateColumnError(
      "Could not add a new column to the DataFrame. The Series name already exists.",
    )
  }
  self.data += [col]
  self.shape = [self.shape[0], self.shape[1] + 1]
  self.index[col.name] = self.shape[1] - 1
}

///| Drop a column from the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `col_name` : The name of the column to be dropped
///
/// ### Return
///
/// - `Unit` : This function drops a column from the DataFrame
///
/// ### Example
/// ```
/// df.drop_column("column_name")
/// ```
pub fn DataFrame::drop_column(
  self : DataFrame,
  col_name : String
) -> Unit raise ColumnNotFoundError {
  match self.index.get(col_name) {
    Some(idx) => {
      let _ = self.data.remove(idx)
      self.index.remove(col_name)
      self.shape = [self.shape[0], self.shape[1] - 1]
      self.index.each(fn(k, v) { if v > idx { self.index[k] = v - 1 } })
    }
    None => raise ColumnNotFoundError("Column '\{col_name}' not found")
  }
}

///| Rename a column in the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `old_name` : The current name of the column to be renamed
/// - `new_name` : The new name for the column
///
/// ### Return
///
/// - `Unit` : This function renames a column in the DataFrame
/// 
/// ### Errors
/// 
/// - `ColumnNotFoundError` : Raised if the column is not found
///
/// ### Example
/// ```
/// test {
///   let mut df = DataFrame::new([Series::new("A", SeriesData::Int([1, 2]))])
///   df.rename("A", "B")
///   inspect!(df.data()[0].name(), context="B")
/// }
/// ```
pub fn DataFrame::rename(
  self : DataFrame,
  old_name : String,
  new_name : String
) -> Unit raise ColumnNotFoundError {
  match self.index.get(old_name) {
    Some(idx) => self.data[idx].name = new_name
    None => raise ColumnNotFoundError("Column '\{old_name}' not found")
  }
}

///| Select a column from the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `col_name` : Column name to be selected
///
/// ### Return
///
/// - `Series` : Series contain selected columns
/// 
/// ### Errors
/// 
/// - `ColumnNotFoundError` : Raised if a column is not found
///
/// ### Example
/// ```
/// let col_selected = df.column("col_name")
/// ```
pub fn DataFrame::column(
  self : DataFrame,
  col_name : String
) -> Series raise ColumnNotFoundError {
  match self.index.get(col_name) {
    Some(idx) => self.data[idx]
    None => raise ColumnNotFoundError("Column '\{col_name}' not found")
  }
}

///| Select specific columns from the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `cols` : An array of column names to be selected
///
/// ### Return
///
/// - `DataFrame` : A new DataFrame containing only the selected columns
/// 
/// ### Errors
/// 
/// - `ColumnNotFoundError` : Raised if a column is not found
///
/// ### Example
/// ```
/// let df_selected = df.select_columns(["col_name1", "col_name2"])
/// ```
pub fn DataFrame::select_columns(
  self : DataFrame,
  cols : Array[String]
) -> DataFrame raise ColumnNotFoundError {
  let selected_cols : Array[Series] = []
  let index : Map[String, Int] = {}
  for name in cols {
    match self.index.get(name) {
      Some(idx) => {
        selected_cols.push(self.data[idx])
        index[name] = selected_cols.length() - 1
      }
      None => raise ColumnNotFoundError("Column '\{name}' not found")
    }
  }
  DataFrame::{
    data: selected_cols,
    shape: [self.shape[0], selected_cols.length()],
    index,
  }
}

///| Drop a row from the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `row` : The index of the row to be dropped
///
/// ### Return
///
/// - `Unit` : This function drops a row from the DataFrame
///
/// ### Errors
///
/// - `IndexOutOfBounds` : Raised if the row index is out of bounds
///
/// ### Example
/// ```
/// df.drop_row(0)
/// ```
pub fn DataFrame::drop_row(self : DataFrame, row_index : Int) -> Unit raise {
  if row_index < 0 || row_index >= self.shape[0] {
    raise IndexOutOfBounds("Row index out of bounds")
  }
  for col in self.data {
    col.data.erase(row_index)
    col.bitmap.bitmap.remove(row_index) |> ignore
    col.length = col.length - 1
  }
  self.shape[0] -= 1
}

///| Add a new row to the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `row` : An array of SeriesValue representing the new row to be added
///
/// ### Return
///
/// - `Unit` : This function adds a new row to the DataFrame
///
/// ### Errors
///
/// - `InconsistentSeriesLength` : Raised if the row length does not match the DataFrame column length
/// - `InvalidType` : if there is a type mismatch
///
/// ### Example
/// ```
/// let mut df = DataFrame::new([
///   Series::new("A", SeriesInput::Int32([1, 2, 3])), 
///   Series::new("B", SeriesInput::Float32([1.1, 2.2, 3.3]))
/// ])
/// df.add_row([SeriesValue::Int(4), SeriesValue::Float(4.4)])
/// ```
pub fn DataFrame::add_row(self : DataFrame, row : Array[SeriesValue]) -> Unit raise{
  guard row.length() == self.shape[1] else {
    raise InconsistentSeriesLength(
      "Row length does not match DataFrame column length",
    )
  }
  for i in 0..<row.length() {
    guard row[i] == SeriesValue::Null ||
      row[i].get_type() == self.data[i].data_type else {
      raise InvalidType("Type mismatch")
    }

  }
  for i in 0..<row.length() {
    match row[i] {
      SeriesValue::Int(value) =>
        match self.data[i].data {
          SeriesData::Int(data) => {
            if self.data[i].bitmap.optional {
              self.data[i].bitmap.bitmap.push(false)
            }
            data.push(value)
          }
          _ => ()
        }
      SeriesValue::Float(value) =>
        match self.data[i].data {
          SeriesData::Float(data) => {
            if self.data[i].bitmap.optional {
              self.data[i].bitmap.bitmap.push(false)
            }
            data.push(value)
          }
          _ => ()
        }
      SeriesValue::Bool(value) =>
        match self.data[i].data {
          SeriesData::Bool(data) => {
            if self.data[i].bitmap.optional {
              self.data[i].bitmap.bitmap.push(false)
            }
            data.push(value)
          }
          _ => ()
        }
      SeriesValue::Str(value) =>
        match self.data[i].data {
          SeriesData::Str(data) => {
            if self.data[i].bitmap.optional {
              self.data[i].bitmap.bitmap.push(false)
            }
            data.push(value)
          }
          _ => ()
        }
      SeriesValue::Null => {
        match self.data[i].bitmap.optional {
          false => self.data[i].bitmap = BitMap::new_by_size(self.shape[0])
          _ => ()
        }
        self.data[i].bitmap.bitmap.push(true)
        self.data[i].bitmap.length += 1
        self.data[i].data.resize(self.shape[0] + 1)
      }
    }
    self.data[i].length += 1
  }
  self.shape[0] += 1
}

///| Select specific rows from the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `range` : An optional tuple representing the range of rows to be selected (inclusive start, exclusive end)
/// - `indices` : An optional array of row indices to be selected
///
/// ### Return
///
/// - `DataFrame` : A new DataFrame containing only the selected rows
/// 
/// ### Errors
/// 
/// - `IndexOutOfBounds` : Raised if the row index is out of bounds
///
/// ### Example
/// ```
/// let df_selected_range = df.select_rows(range=(1, 4))
/// 
/// let df_selected_indices = df.select_rows(indices=[1, 3, 5])
/// ```
pub fn DataFrame::select_rows(
  self : DataFrame,
  range? : (Int, Int),
  indices? : Array[Int]
) -> DataFrame raise IndexOutOfBounds {
  match (range, indices) {
    (Some(_), _) => {
      let selected_rows : Array[Series] = []
      for col in self.data {
        let (begin, end) = match range {
          Some(r) => r
          None => abort("Range is None")
        }
        selected_rows.push(col.slice(begin, end))
      }
      DataFrame::{
        data: selected_rows,
        shape: [selected_rows[0].data.length(), self.shape[1]],
        index: self.index,
      }
    }
    (_, Some(_)) =>
      match indices {
        Some(i) => {
          // boundary check
          i.sort()
          if i[0] < 0 || i[i.length() - 1] >= self.shape[0] {
            raise IndexOutOfBounds("Row index out of bounds")
          }
          // select rows
          let selected_rows : Array[Series] = []
          for col in self.data {
            let mut series_data : SeriesData = emptySeriesData(col.data_type)
            match col.data {
              SeriesData::Int(data) => {
                let col_data = []
                for idx in i {
                  col_data.push(data[idx])
                }
                series_data = SeriesData::Int(col_data)
              }
              SeriesData::Float(data) => {
                let col_data = []
                for idx in i {
                  col_data.push(data[idx])
                }
                series_data = SeriesData::Float(col_data)
              }
              SeriesData::Bool(data) => {
                let col_data = []
                for idx in i {
                  col_data.push(data[idx])
                }
                series_data = SeriesData::Bool(col_data)
              }
              SeriesData::Str(data) => {
                let col_data = []
                for idx in i {
                  col_data.push(data[idx])
                }
                series_data = SeriesData::Str(col_data)
              }
            }
            selected_rows.push(Series::{
              name: col.name(),
              data: series_data,
              data_type: col.data_type,
              bitmap: col.bitmap.select_rows(i),
              length: i.length(),
            })
          }
          DataFrame::{
            data: selected_rows,
            shape: [selected_rows[0].data.length(), self.shape[1]],
            index: self.index,
          }
        }
        None => emptyDataFrame
      }
    (None, None) => emptyDataFrame
  }
}

///|
pub fn op_get(self : DataFrame, index : Int) -> DataFrame {
  let row = []
  for col in self.data {
    let mut series_data = emptySeriesData(col.data_type)
    match col.data {
      SeriesData::Int(data) => series_data = SeriesData::Int([data[index]])
      SeriesData::Float(data) => series_data = SeriesData::Float([data[index]])
      SeriesData::Bool(data) => series_data = SeriesData::Bool([data[index]])
      SeriesData::Str(data) => series_data = SeriesData::Str([data[index]])
    }
    row.push(Series::{
      name: col.name,
      data: series_data,
      data_type: col.data_type,
      bitmap: col.bitmap.slice(index, length=1),
      length: 1,
    })
  }
  DataFrame::{ data: row, shape: [1, self.shape()[1]], index: self.index }
}

///| Filter rows in the DataFrame based on a condition
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `name` : The name of the column to apply the filter on
/// - `f` : A function that takes a `SeriesValue` and returns a `Bool` indicating whether the row should be included
///
/// ### Return
///
/// - `DataFrame` : A new DataFrame containing only the rows that satisfy the condition
///
/// ### Example
/// ```
/// let df = DataFrame::new([Series::new("A", SeriesData::Int([1, 2, 3, 4, 5, 6]))])
/// let filtered = df.filter("A", fn(x : SeriesValue) -> Bool { x < SeriesValue::Int(3) })
/// ```
pub fn DataFrame::filter(
  self : DataFrame,
  name : String,
  f : (SeriesValue) -> Bool
) -> DataFrame raise {
  match self.index.get(name) {
    Some(index) =>
      match self.data[index].data {
        SeriesData::Int(data) => {
          let rows = Array::new()
          for i in 0..<data.length() {
            if f(SeriesValue::Int(data[i])) {
              rows.push(i)
            }
          }
          self.select_rows(indices=rows)
        }
        SeriesData::Float(data) => {
          let rows = Array::new()
          for i in 0..<data.length() {
            if f(SeriesValue::Float(data[i])) {
              rows.push(i)
            }
          }
          self.select_rows(indices=rows)
        }
        SeriesData::Bool(data) => {
          let rows = Array::new()
          for i in 0..<data.length() {
            if f(SeriesValue::Bool(data[i])) {
              rows.push(i)
            }
          }
          self.select_rows(indices=rows)
        }
        SeriesData::Str(data) => {
          let rows = Array::new()
          for i in 0..<data.length() {
            if f(SeriesValue::Str(data[i])) {
              rows.push(i)
            }
          }
          self.select_rows(indices=rows)
        }
      }
    None => emptyDataFrame
  }
}

///| Sort the DataFrame by a specified column
///
/// Parameters
///
/// - `self` : An instance of the DataFrame
/// - `by` : The name of the column to sort by
/// - `descending` : Whether to sort in descending order (default is false)
/// - `nulls_last` : Whether to place null values at the end (default is false)
///
/// Returns
///
/// - `Unit` : This function sorts the DataFrame in place
///
/// Errors
///
/// - `ColumnNotFoundError` : Raised if the specified column is not found
///
/// Example
/// ```
/// let df = DataFrame::new([
///   Series::new("A", SeriesData::Int([3, 1, 2])), 
///   Series::new("B", SeriesData::Float([3.3, 1.1, 2.2]))
/// ])
/// df.sort("B", descending=true)
/// inspect!(df.data()[0].data(), content="Int([3, 2, 1])")
/// ```
pub fn DataFrame::sort(
  self : DataFrame,
  by : String,
  descending~ : Bool = false,
  nulls_last~ : Bool = false
) -> Unit raise ColumnNotFoundError {
  match self.index.get(by) {
    Some(index) => {
      let indices = self.data[index].get_argsort_indices(
        descending~,
        nulls_last~,
      )
      for item in self.data {
        item.data.argsort_indices(indices)
      }
    }
    None => raise ColumnNotFoundError("Column '\{by}' not found.")
  }
}

///| Vertically stack two DataFrames
///
/// Parameters
///
/// - `self` : An instance of the DataFrame
/// - `other` : Another DataFrame to be stacked vertically
/// - `inplace` : Whether to stack in place (default is false)
///
/// Returns
///
/// - `DataFrame` : A new DataFrame resulting from the vertical stacking of the two DataFrames
///
/// Errors
///
/// - `InconsistentSeriesLength` : Raised if the number of columns in the two DataFrames is not the same
/// - `InvalidType` : Raised if the data types of the corresponding columns in the two DataFrames are not the same
///
/// Example
/// ```
/// let df_stacked = df1.vstack!(df2)
/// ```
pub fn vstack(
  self : DataFrame,
  other : DataFrame,
  inplace~ : Bool = false
) -> DataFrame raise{
  guard self.shape[1] == other.shape[1] else {
    raise InconsistentSeriesLength("The number of columns must be the same.")
  }
  match inplace {
    true => {
      for serie in self.data {
        Series::merge(serie, other.column(serie.name()), inplace=true)
        |> ignore
      }
      self
    }
    false => {
      let data : Array[Series] = []
      for serie in self.data {
        data.push(
          Series::merge(serie, other.column(serie.name()), inplace=false),
        )
      }
      DataFrame::new(data)
    }
  }
}

///| Horizontally stack two DataFrames
///
/// Parameters
///
/// - `self` : An instance of the DataFrame
/// - `other` : Another DataFrame to be stacked horizontally
/// - `inplace` : Whether to stack in place (default is false)
///
/// Returns
///
/// - `DataFrame` : A new DataFrame resulting from the horizontal stacking of the two DataFrames
///
/// Example
/// ```
/// df1.hstack!(df2) |> ignore
/// ```
pub fn hstack(
  self : DataFrame,
  other : DataFrame,
  inplace~ : Bool = false
) -> DataFrame raise{
  match inplace {
    false => {
      let data : Array[Series] = self.data.copy()
      for series in other.data {
        if not(self.index.contains(series.name())) {
          data.push(series)
        }
      }
      DataFrame::new(data)
    }
    true => {
      for series in other.data {
        if not(self.index.contains(series.name())) {
          self.add_column(series)
        }
      }
      self
    }
  }
}

///|
test "DataFrame::hstack" {
  let df1 = DataFrame::new([Series::new("A", SeriesInput::Int32([1, 2, 3]))])
  let df2 = DataFrame::new([Series::new("B", SeriesInput::Int32([4, 5, 6]))])
  let df_stacked = df1.hstack(df2)
  inspect(df_stacked.data[0].name(), content="A")
  inspect(df_stacked.data[1].name(), content="B")
  df1.hstack(df2, inplace=true) |> ignore
  inspect(df1.data[0].name(), content="A")
  inspect(df1.data[1].name(), content="B")
}

///|
/// Clears all data in the DataFrame, resetting it to an empty state.
///
/// ### Parameters:
///
/// - `self` : The DataFrame to be cleared.
/// - `n` : Number of (null-filled) rows to return in the cleared frame
///
/// ### Example:
///
/// ```
/// df.clear()
/// df.clear(n=1)
/// ```
pub fn DataFrame::clear(self : DataFrame, n~ : Int = 0) -> DataFrame {
  let data : Array[Series] = []
  for serie in self.data {
    data.push(serie.clear(n~))
  }
  DataFrame::{ data, shape: [n, self.shape[1]], index: self.index }
}

///|
/// Creates a deep copy of the DataFrame.
///
/// ### Parameters:
///
/// - `self` : The DataFrame to be cloned.
///
/// ### Return:
/// Return a new DataFrame with the same data, shape, and index as the original
/// DataFrame. All internal data structures are deeply copied.
/// THIS METHOD Under Consideration...
///
/// ### Example:
///
/// ```
/// let cloned = df.clone()
/// ```
pub fn DataFrame::clone(self : DataFrame) -> DataFrame {
  let data = self.data.map(fn(series : Series) { series.copy() })
  let index = self.index.iter().collect()
  let map : Map[String, Int] = {}
  for idx in index {
    map[idx.0] = idx.1
  }
  DataFrame::{ data, shape: self.shape.copy(), index: map }
}

///|
pub(all) enum ColumnSelector {
  Int(Int)
  Str(String)
}

///|
/// Retrieves a single item from the DataFrame at the specified row and column.
///
/// ### Parameters:
///
/// - `self` : The DataFrame to retrieve the item from.
/// - `row` : The index of the row (zero-based).
/// - `column` : The column identifier, can be either:
///  * `ColumnSelector::Int`: A zero-based index of the column
///  * `ColumnSelector::Str`: The name of the column
///
/// Returns a `SeriesValue` value representing the item at the specified position.
///
/// Throws:
///
/// - `ColumnNotFoundError` : If the specified column name does not exist in the
/// DataFrame
/// - `IndexOutOfBounds` : If the row index is out of range
///
/// ### Example:
///
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3])),
///   Series::new("B", SeriesData::Float([1.5, 2.0, 3.5])),
/// ])
/// df.item!(1, ColumnSelector::Str("A"))
/// df.item!(0, ColumnSelector::Int(1))
/// ```
pub fn DataFrame::item(
  self : DataFrame,
  row : Int,
  column : ColumnSelector
) -> SeriesValue raise{
  let col = match column {
    ColumnSelector::Int(value) => value
    ColumnSelector::Str(value) =>
      match self.index.get(value) {
        Some(idx) => idx
        None => raise ColumnNotFoundError("Column '\{value}' not found")
      }
  }
  if row < 0 || row >= self.shape()[0] || col < 0 || col >= self.shape()[1] {
    raise IndexOutOfBounds("Row index out of bounds")
  }
  self.data[col][row]
}

///|
/// Creates a new DataFrame containing only the first N rows of the original
/// DataFrame. If N is larger than the number of rows in the DataFrame, returns a
/// DataFrame with all rows from the original DataFrame.
///
/// ### Parameters:
///
/// - `self` : The DataFrame to limit.
/// - `n` : The maximum number of rows to include in the new DataFrame.
///
/// ### Return:
/// 
/// Return a new DataFrame containing at most N rows from the original
/// DataFrame.
///
/// Throws an error of type `Error` if creating the new DataFrame fails.
///
/// ### Example:
///
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3, 4, 5])),
///   Series::new("B", SeriesData::Float([1.1, 2.2, 3.3, 4.4, 5.5])),
/// ])
/// let limited = df.limit!(3)
/// ```
pub fn limit(self : DataFrame, n : Int) -> DataFrame raise{
  let data : Array[Series] = []
  let n = @math.minimum(n, self.shape()[0])
  for series in self.data {
    let new_data = match series.data {
      SeriesData::Int(data) => SeriesData::Int(data.split_at(n).0)
      SeriesData::Float(data) => SeriesData::Float(data.split_at(n).0)
      SeriesData::Bool(data) => SeriesData::Bool(data.split_at(n).0)
      SeriesData::Str(data) => SeriesData::Str(data.split_at(n).0)
    }
    data.push(Series::new_by_SeriesData(series.name, new_data))
  }
  DataFrame::new(data)
}

///|
/// Creates a new DataFrame containing only the last N rows of the original
/// DataFrame. If N is larger than the number of rows in the DataFrame, returns a
/// DataFrame with all rows from the original DataFrame.
///
/// ### Parameters:
///
/// - `self` : The DataFrame to extract rows from.
/// - `n` : The number of rows to include from the end of the DataFrame.
///
/// ### Return:
/// 
/// Returns a new DataFrame containing at most N rows from the end of the
/// original DataFrame.
///
/// Throws an error of type `Error` if creating the new DataFrame fails.
///
/// ### Example:
///
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3, 4, 5])),
///   Series::new("B", SeriesData::Float([1.1, 2.2, 3.3, 4.4, 5.5])),
/// ])
/// let last_three = df.tail!(3)
/// ```
pub fn tail(self : DataFrame, n : Int) -> DataFrame raise {
  let data : Array[Series] = []
  let n = @math.minimum(n, self.shape()[0])
  for series in self.data {
    let new_data = match series.data {
      SeriesData::Int(data) =>
        SeriesData::Int(data.split_at(data.length() - n).1)
      SeriesData::Float(data) =>
        SeriesData::Float(data.split_at(data.length() - n).1)
      SeriesData::Bool(data) =>
        SeriesData::Bool(data.split_at(data.length() - n).1)
      SeriesData::Str(data) =>
        SeriesData::Str(data.split_at(data.length() - n).1)
    }
    data.push(Series::new_by_SeriesData(series.name, new_data))
  }
  DataFrame::new(data)
}

///|
/// Creates a new DataFrame containing a slice of rows from the original
/// DataFrame, starting from the specified offset.
///
/// Parameters:
///
/// * `self` : The DataFrame to slice.
/// * `offset` : The starting index of the slice (zero-based).
/// * `length` : Specifying the number of rows to include in
/// the slice. If not provided, includes all remaining rows after the offset.
///
/// Returns a new DataFrame containing the specified slice of rows from the
/// original DataFrame.
///
/// Throws an error of type `Error` if creating the new DataFrame fails.
///
/// Example:
///
/// ```moonbit
///   let df = DataFrame::new!([
///     Series::new("A", SeriesData::Int([1, 2, 3, 4, 5])),
///     Series::new("B", SeriesData::Float([1.1, 2.2, 3.3, 4.4, 5.5])),
///   ])
///   let sliced = df.slice!(1, length=2)
/// ```
pub fn DataFrame::slice(
  self : DataFrame,
  offset : Int,
  length? : Int
) -> DataFrame raise{
  let len = match length {
    Some(l) => l
    None => self.shape()[0] - offset
  }
  if len < 0 || offset + len > self.shape()[0] {
    raise IndexOutOfBounds("length cannot be negative")
  } else {
    let data : Array[Series] = []
    for series in self.data {
      let new_data = match series.data {
        SeriesData::Int(data) =>
          SeriesData::Int(data.split_at(offset).1.split_at(len).0)
        SeriesData::Float(data) =>
          SeriesData::Float(data.split_at(offset).1.split_at(len).0)
        SeriesData::Bool(data) =>
          SeriesData::Bool(data.split_at(offset).1.split_at(len).0)
        SeriesData::Str(data) =>
          SeriesData::Str(data.split_at(offset).1.split_at(len).0)
      }
      data.push(Series::new_by_SeriesData(series.name, new_data))
    }
    DataFrame::new(data)
  }
}

///|
/// Converts a column of the DataFrame to a Series by its index.
///
/// Parameters:
///
/// * `self` : The DataFrame from which to extract the Series.
/// * `column_index` : The zero-based index of the column to convert to a Series.
///
/// Returns the Series at the specified column index.
///
/// Example:
///
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3])),
///   Series::new("B", SeriesData::Float([1.5, 2.0, 2.5])),
/// ])
/// df.to_series(0)
/// ```
pub fn to_series(self : DataFrame, index : Int) -> Series {
  self.data[index]
}

///|
/// Removes duplicate rows from the DataFrame based on specified columns, with
/// control over which duplicates to keep.
///
/// Parameters:
///
/// * `df` : The DataFrame to remove duplicates from.
/// * `columns` : An array of column names to consider when identifying
/// duplicates. Rows are considered duplicates if they have the same values in
/// all specified columns.
/// * `keep~` : A string specifying which duplicates to retain. Valid values are:
///  * "first": Keep the first occurrence of each duplicate
///  * "last": Keep the last occurrence of each duplicate
///  * "any": Keep any occurrence of each duplicate (defaults to first)
///  * "none": Keep only rows that have no duplicates
///
/// Returns a new DataFrame with duplicates removed according to the specified
/// criteria.
///
/// Throws:
///
/// * `InvalidType` : If an invalid value is provided for the `keep` parameter
/// * `ColumnNotFoundError` : If any of the specified columns do not exist in the
/// DataFrame
///
/// Example:
///
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 1, 2, 2])),
///   Series::new("B", SeriesData::Int([1, 1, 2, 3])),
/// ])
/// let unique_df = df.unique!(["A"], keep="first")
/// ```
pub fn unique(
  self : DataFrame,
  subset : Array[String],
  keep~ : String = "any"
) -> DataFrame raise{
  if not(["first", "last", "any", "none"].contains(keep)) {
    raise InvalidType(
      "Invalid keep parameter. Must be one of: first, last, any, none",
    )
  }
  let selected_cols = []
  for item in subset {
    selected_cols.push(self.column(item))
  }
  let df = DataFrame::new(selected_cols)
  let unique_map = Map::new() // key: row_string, value: Array[Int]
  for i = 0; i < df.shape()[0]; i = i + 1 {
    let row_key = df.select_rows(range=(i, i + 1)).to_string()
    if unique_map.contains(row_key) {
      let current_indices = match unique_map.get(row_key) {
        Some(indices) => indices
        None => []
      }
      let new_indices = current_indices + [i]
      unique_map.set(row_key, new_indices)
    } else {
      unique_map.set(row_key, [i])
    }
  }
  let unique_indices = Array::new()
  for indice in unique_map {
    let indices = indice.1
    match keep {
      "first" => unique_indices.push(indices[0])
      "last" => unique_indices.push(indices[indices.length() - 1])
      "any" => unique_indices.push(indices[0])
      _ => if indices.length() == 1 { unique_indices.push(indices[0]) }
    }
  }
  unique_indices.sort()
  match unique_indices.length() {
    0 => emptyDataFrame
    _ => self.select_rows(indices=unique_indices)
  }
}

///| Replace a column in the DataFrame at a specified index
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `index` : The index of the column to be replaced
/// - `series` : The new Series to replace the existing column
///
/// ### Errors
///
/// - `IndexOutOfBounds` : Raised if the specified index is out of bounds
/// - `InconsistentSeriesLength` : Raised if the length of the new Series does not match the number of rows in the DataFrame
///
/// ### Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3])),
///   Series::new("B", SeriesData::Float([1.1, 2.2, 3.3]))
/// ])
/// let new_series = Series::new("C", SeriesData::Int([4, 5, 6]))
/// df.replace_column(1, new_series)
/// ```
pub fn DataFrame::replace_column(
  self : DataFrame,
  index : Int,
  series : Series
) -> Unit raise {
  guard index >= 0 && index < self.shape[1] else {
    raise IndexOutOfBounds("Index out of bounds")
  }
  guard series.data.length() == self.shape[0] else {
    raise InconsistentSeriesLength("The number of columns must be the same")
  }
  self.data[index] = series
}

///| Reverse the order of rows in the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Example
/// ```moonbit
/// df.reverse()
/// ```
pub fn DataFrame::reverse(self : DataFrame) -> Unit {
  for series in self.data {
    series.reverse()
  }
}

///| Get the index of a column by its name
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `name` : The name of the column
///
/// ### Errors
///
/// - `ColumnNotFoundError` : Raised if the specified column is not found
///
/// ### Example
/// ```moonbit
/// let index = df.get_column_index("A")
/// ```
pub fn DataFrame::get_column_index(self : DataFrame, name : String) -> Int raise {
  match self.index.get(name) {
    Some(index) => index
    None => raise ColumnNotFoundError("Column '\{name}' not found")
  }
}

///| Add a row index column to the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `offset` : An optional integer offset to start the row index (default is 0)
///
/// ### Returns
///
/// - `DataFrame` : A new DataFrame with an added row index column
///
/// ### Example
/// ```
/// let df_with_index = df.with_row_index()
/// ```
pub fn DataFrame::with_row_index(
  self : DataFrame,
  offset~ : Int = 0
) -> DataFrame {
  let new_data = self.data.copy()
  let idx = Series::new_by_SeriesData(
    "index",
    SeriesData::Int(Array::makei(self.shape[0], fn(i) { i + offset })),
  )
  new_data.insert(0, idx)
  let new_index = { "row_nr": 0 }
  for item in self.index {
    new_index[item.0] = item.1 + 1
  }
  DataFrame::{
    data: new_data,
    shape: [self.shape[0], self.shape[1] + 1],
    index: new_index,
  }
}

///| Transpose a DataFrame over the diagonal
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `include_header~` : If set, the column names will be added as first column. (default is false)
/// - `header_name~` : If include_header is set, this determines the name of the column that will be inserted. (default is "column")
/// - `column_names?` : Optional iterable yielding strings or a string naming an existing column. These will name the value (non-header) columns in the transposed data.
///
/// ### Returns
///
/// - `DataFrame` : A new transposed DataFrame
///
/// ### Errors
///
/// - `InvalidType` : Raised if the columns have different data types
///
/// ### Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3])),
///   Series::new("B", SeriesData::Int([4, 5, 6]))
/// ])
/// let df_transposed = df.transpose()
/// let df_transposed = df.transpose(include_header=true)
/// let df_transposed = df.transpose(include_header=true, header_name="header")
/// let df_transposed = df.transpose(column_names=["x","y"])
/// ```
pub fn DataFrame::transpose(
  self : DataFrame,
  include_header~ : Bool = false,
  header_name~ : String = "column",
  column_names? : Array[String]
) -> DataFrame raise{
  for series in self.data {
    if series.get_type() != self.data[0].get_type() {
      raise InvalidType("All columns must have the same data type")
    }
  }
  let new_data : Array[Series] = []
  match include_header {
    true => {
      let header = Series::new_by_SeriesData(
        header_name,
        SeriesData::Str(
          Array::makei(self.shape[1], fn(i) { self.data[i].name }),
        ),
      )
      new_data.push(header)
    }
    false => ()
  }
  match self.data[0].data {
    Int(_) =>
      for i = 0; i < self.shape[0]; i = i + 1 {
        let col_data = []
        for j = 0; j < self.shape[1]; j = j + 1 {
          match self.data[j][i] {
            SeriesValue::Int(value) => col_data.push(value)
            _ => ()
          }
        }
        let col_name = "column_" + i.to_string()
        new_data.push(
          Series::new_by_SeriesData(col_name, SeriesData::Int(col_data)),
        )
      }
    Float(_) =>
      for i = 0; i < self.shape[0]; i = i + 1 {
        let col_data = []
        for j = 0; j < self.shape[1]; j = j + 1 {
          match self.data[j][i] {
            SeriesValue::Float(value) => col_data.push(value)
            _ => ()
          }
        }
        let col_name = "column_" + i.to_string()
        new_data.push(
          Series::new_by_SeriesData(col_name, SeriesData::Float(col_data)),
        )
      }
    Bool(_) =>
      for i = 0; i < self.shape[0]; i = i + 1 {
        let col_data = []
        for j = 0; j < self.shape[1]; j = j + 1 {
          match self.data[j][i] {
            SeriesValue::Bool(value) => col_data.push(value)
            _ => ()
          }
        }
        let col_name = "column_" + i.to_string()
        new_data.push(
          Series::new_by_SeriesData(col_name, SeriesData::Bool(col_data)),
        )
      }
    Str(_) =>
      for i = 0; i < self.shape[0]; i = i + 1 {
        let col_data = []
        for j = 0; j < self.shape[1]; j = j + 1 {
          match self.data[j][i] {
            SeriesValue::Str(value) => col_data.push(value)
            _ => ()
          }
        }
        let col_name = "column_" + i.to_string()
        new_data.push(
          Series::new_by_SeriesData(col_name, SeriesData::Str(col_data)),
        )
      }
  }
  match column_names {
    Some(names) =>
      for i = 0; i < @math.minimum(names.length(), new_data.length()); i = i + 1 {
        new_data[i].name = names[i]
      }
    None => ()
  }
  let new_index : Map[String, Int] = {}
  for i = 0; i < new_data.length(); i = i + 1 {
    new_index[new_data[i].name] = i
  }
  DataFrame::{
    data: new_data,
    shape: [new_data[0].data.length(), new_data.length()],
    index: new_index,
  }
}

///| Aggregate the columns of this DataFrame to their minimum value
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Returns
///
/// - `DataFrame` : A new DataFrame containing the minimum value of each column
///
/// ### Example
/// ```
/// let df_min = df.min()
/// ```
pub fn DataFrame::min(self : DataFrame) -> DataFrame raise{
  let data : Array[Series] = []
  for series in self.data {
    let min = series.min()
    match min {
      SeriesValue::Float(value) =>
        data.push(
          Series::new_by_SeriesData(series.name, SeriesData::Float([value])),
        )
      SeriesValue::Int(value) =>
        data.push(
          Series::new_by_SeriesData(series.name, SeriesData::Int([value])),
        )
      SeriesValue::Bool(value) =>
        data.push(
          Series::new_by_SeriesData(series.name, SeriesData::Bool([value])),
        )
      SeriesValue::Str(value) =>
        data.push(
          Series::new_by_SeriesData(series.name, SeriesData::Str([value])),
        )
      SeriesValue::Null =>
        match series.get_type() {
          DataType::Int32 =>
            data.push(
              Series::new(series.name, SeriesInput::Int32_Nullable([None])),
            )
          DataType::Float32 =>
            data.push(
              Series::new(series.name, SeriesInput::Float32_Nullable([None])),
            )
          DataType::Bool =>
            data.push(
              Series::new(series.name, SeriesInput::Bool_Nullable([None])),
            )
          DataType::String =>
            data.push(
              Series::new(series.name, SeriesInput::Str_Nullable([None])),
            )
        }
    }
  }
  DataFrame::{ data, shape: [1, self.shape[1]], index: self.index }
}

///| Get the minimum value horizontally across columns.
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Returns
///
/// - `Series` : A Series containing the minimum value of each column
///
/// ### Errors
///
/// - `InvalidType` : Raised if the DataFrame contains unsupported data types
///
/// ### Example
/// ```
/// let max = df.min_horizontal()
/// ```
pub fn DataFrame::min_horizontal(self : DataFrame) -> Series raise {
  for series in self.data {
    match series.get_type() {
      DataType::Int32 => ()
      DataType::Float32 => ()
      _ => raise InvalidType("Contains unsupported data type")
    }
  }
  let data = Series::{
    name: "sum",
    data: SeriesData::Float(Array::make(self.shape[0], @float.max_value)),
    data_type: DataType::Float32,
    bitmap: emptyBitMap,
    length: self.shape[0],
  }
  for series in self.data {
    data.data.min(series.data)
  }
  data
}

///| Aggregate the columns of this DataFrame to their maximum value
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Returns
///
/// - `DataFrame` : A new DataFrame containing the maximum value of each column
///
/// ### Example
/// ```
/// let df_min = df.max()
/// ```
pub fn DataFrame::max(self : DataFrame) -> DataFrame raise {
  let data : Array[Series] = []
  for series in self.data {
    let max = series.max()
    match max {
      SeriesValue::Float(value) =>
        data.push(
          Series::new_by_SeriesData(series.name, SeriesData::Float([value])),
        )
      SeriesValue::Int(value) =>
        data.push(
          Series::new_by_SeriesData(series.name, SeriesData::Int([value])),
        )
      SeriesValue::Bool(value) =>
        data.push(
          Series::new_by_SeriesData(series.name, SeriesData::Bool([value])),
        )
      SeriesValue::Str(value) =>
        data.push(
          Series::new_by_SeriesData(series.name, SeriesData::Str([value])),
        )
      SeriesValue::Null =>
        match series.get_type() {
          DataType::Int32 =>
            data.push(
              Series::new(series.name, SeriesInput::Int32_Nullable([None])),
            )
          DataType::Float32 =>
            data.push(
              Series::new(series.name, SeriesInput::Float32_Nullable([None])),
            )
          DataType::Bool =>
            data.push(
              Series::new(series.name, SeriesInput::Bool_Nullable([None])),
            )
          DataType::String =>
            data.push(
              Series::new(series.name, SeriesInput::Str_Nullable([None])),
            )
        }
    }
  }
  DataFrame::{ data, shape: [1, self.shape[1]], index: self.index }
}

///| Get the maximum value horizontally across columns.
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Returns
///
/// - `Series` : A Series containing the maximum value of each column
///
/// ### Errors
///
/// - `InvalidType` : Raised if the DataFrame contains unsupported data types
///
/// ### Example
/// ```
/// let max = df.max_horizontal()
/// ```
pub fn DataFrame::max_horizontal(self : DataFrame) -> Series raise {
  for series in self.data {
    match series.get_type() {
      DataType::Int32 => ()
      DataType::Float32 => ()
      _ => raise InvalidType("Contains unsupported data type")
    }
  }
  let data = Series::{
    name: "sum",
    data: SeriesData::Float(Array::make(self.shape[0], @float.min_value)),
    data_type: DataType::Float32,
    bitmap: emptyBitMap,
    length: self.shape[0],
  }
  for series in self.data {
    data.data.max(series.data)
  }
  data
}

///| Calculate the sum of each column in the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Returns
///
/// - `DataFrame` : A new DataFrame containing the sum of each column
///
/// ### Errors
///
/// - `InvalidType` : Raised if the Series data type is not supported
///
/// ### Example
/// ```
/// let df_sum = df.sum()
/// ```
pub fn DataFrame::sum(self : DataFrame) -> DataFrame raise {
  let data : Array[Series] = []
  for series in self.data {
    let sum = series.sum()
    match sum {
      SeriesValue::Float(value) =>
        data.push(
          Series::new_by_SeriesData(series.name, SeriesData::Float([value])),
        )
      SeriesValue::Int(value) =>
        data.push(
          Series::new_by_SeriesData(series.name, SeriesData::Int([value])),
        )
      _ => ()
    }
  }
  DataFrame::{ data, shape: [1, self.shape[1]], index: self.index }
}

///| Sum all values horizontally across columns
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Returns
///
/// - `Series` : A Series containing the sum of each row
///
/// ### Errors
///
/// - `InvalidType` : Raised if the DataFrame contains unsupported data types
///
/// ### Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3])),
///   Series::new("B", SeriesData::Float([1.5, 2.5, 3.0]))
/// ])
/// let sum = df.sum_horizontal!()
/// ```
pub fn DataFrame::sum_horizontal(self : DataFrame) -> Series raise {
  for series in self.data {
    match series.get_type() {
      DataType::Int32 => ()
      DataType::Float32 => ()
      _ => raise InvalidType("Contains unsupported data type")
    }
  }
  let mut data = Series::{
    name: "sum",
    data: SeriesData::Float(Array::make(self.shape[0], (0.0 : Float))),
    data_type: DataType::Float32,
    bitmap: emptyBitMap,
    length: self.shape[0],
  }
  for series in self.data {
    data += series
  }
  data
}

///|
pub fn DataFrame::count(self : DataFrame) -> (Int, Int) {
  (self.shape[0], self.shape[1])
}

///| Get the number of rows
pub fn DataFrame::height(self : DataFrame) -> Int {
  self.shape[0]
}

///| Get the number of columns
pub fn DataFrame::width(self : DataFrame) -> Int {
  self.shape[1]
}

///| Get an ordered mapping of column names to their data type
/// 
/// Example:
/// ```
/// let schema = df.schema()
/// ```
pub fn DataFrame::schema(self : DataFrame) -> Map[String, String] {
  let schema : Map[String, String] = {}
  for series in self.data {
    schema[series.name] = series.get_type().to_string()
  }
  schema
}

///| Aggregate the columns of this DataFrame to their product values
/// 
/// Example:
/// ```
/// let df_product = df.product()
/// ```
pub fn DataFrame::product(self : DataFrame) -> DataFrame {
  let data : Array[Series] = []
  for series in self.data {
    match series.data {
      SeriesData::Int(arr) =>
        data.push(
          Series::new_by_SeriesData(
            series.name,
            SeriesData::Int([arr.iter().fold(init=1, fn(acc, x) { acc * x })]),
          ),
        )
      SeriesData::Float(arr) =>
        data.push(
          Series::new_by_SeriesData(
            series.name,
            SeriesData::Float([arr.iter().fold(init=1, fn(acc, x) { acc * x })]),
          ),
        )
      _ =>
        data.push(Series::new_by_SeriesData(series.name, SeriesData::Int([0])))
    }
  }
  DataFrame::{ data, shape: [1, self.shape[1]], index: self.index }
}

///| Get the column data types
pub fn DataFrame::dtypes(self : DataFrame) -> Array[String] {
  self.data.map(fn(series) { series.get_type().to_string() })
}

///|
fn DataFrame::type_check_all(self : DataFrame, data_type : DataType) -> Bool {
  for series in self.data {
    if series.get_type() != data_type {
      return false
    }
  }
  true
}

///| Check if each column in the DataFrame has null values
///
/// Parameters
///
/// - `self` : An instance of the DataFrame
///
/// Returns
///
/// - `DataFrame` : A new DataFrame with a single row indicating if each column has null values
///
/// Example
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesInput::Bool([true, true, true])),
///   Series::new("B", SeriesInput::Bool([true, false, true])),
/// ])
/// inspect!(df.all!().data[0][0], content="Bool(true)")
/// inspect!(df.all!().data[1][0], content="Bool(false)")
/// ```
pub fn DataFrame::all(
  self : DataFrame,
  ignore_nulls~ : Bool = true
) -> DataFrame raise {
  guard self.type_check_all(DataType::Bool) else {
    raise InvalidType("All columns must be of type Bool")
  }
  match ignore_nulls {
    true => {
      let data = []
      for i = 0; i < self.shape[1]; i = i + 1 {
        data.push(
          Series::new(
            self.data[i].name,
            SeriesInput::Bool([self.data[i].all()]),
          ),
        )
      }
      DataFrame::new(data)
    }
    false => {
      let data = []
      for i = 0; i < self.shape[1]; i = i + 1 {
        if self.data[i].has_null() {
          data.push(
            Series::new(self.data[i].name, SeriesInput::Bool_Nullable([None])),
          )
        } else {
          data.push(
            Series::new(
              self.data[i].name,
              SeriesInput::Bool_Nullable([Some(self.data[i].all())]),
            ),
          )
        }
      }
      DataFrame::new(data)
    }
  }
}

///| Check if any element in each column of the DataFrame is true
///
/// Parameters
///
/// - `self` : An instance of the DataFrame
/// - `ignore_nulls` : Whether to ignore null values (default is true)
///
/// Returns
///
/// - `DataFrame` : A new DataFrame with a single row indicating if any element in each column is true
///
/// Errors
///
/// - `InvalidType` : Raised if any column is not of type Bool
///
/// Example
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesInput::Bool([true, true, true])),
///   Series::new("B", SeriesInput::Bool([true, false, true])),
/// ])
/// inspect!(df.any!().data[0][0], content="Bool(true)")
/// inspect!(df.any!().data[1][0], content="Bool(true)")
/// ```
pub fn DataFrame::any(
  self : DataFrame,
  ignore_nulls~ : Bool = true
) -> DataFrame raise{
  guard self.type_check_all(DataType::Bool) else {
    raise InvalidType("All columns must be of type Bool")
  }
  match ignore_nulls {
    true => {
      let data = []
      for i = 0; i < self.shape[1]; i = i + 1 {
        data.push(
          Series::new(
            self.data[i].name,
            SeriesInput::Bool([self.data[i].any()]),
          ),
        )
      }
      DataFrame::new(data)
    }
    false => {
      let data = []
      for i = 0; i < self.shape[1]; i = i + 1 {
        if self.data[i].has_null() {
          data.push(
            Series::new(self.data[i].name, SeriesInput::Bool_Nullable([None])),
          )
        } else {
          data.push(
            Series::new(
              self.data[i].name,
              SeriesInput::Bool_Nullable([Some(self.data[i].any())]),
            ),
          )
        }
      }
      DataFrame::new(data)
    }
  }
}

///| Check if each column in the DataFrame has null values
///
/// Parameters
///
/// - `self` : An instance of the DataFrame
///
/// Returns
///
/// - `DataFrame` : A new DataFrame with a single row indicating if each column has null values
///
/// Example
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesInput::Int32([1, 2, 3])),
/// ])
/// inspect!(df.has_nulls().data[0][0], content="Bool(false)")
/// let df = DataFrame::new!([
///   Series::new("A", SeriesInput::Int32_Nullable([Some(1), None, Some(3)])),
/// ])
/// inspect!(df.has_nulls().data[0][0], content="Bool(true)")
/// ```
pub fn DataFrame::has_nulls(self : DataFrame) -> DataFrame {
  let data = []
  for serie in self.data {
    let has_null = match serie.bitmap.optional {
      false => false
      true => serie.bitmap.has_nulls()
    }
    data.push(Series::new(serie.name, SeriesInput::Bool([has_null])))
  }
  DataFrame::{ data, shape: [1, self.shape[1]], index: self.index }
}

///| Create a new DataFrame that shows the null counts per column.
pub fn DataFrame::null_count(self : DataFrame) -> DataFrame {
  let data = []
  for serie in self.data {
    data.push(
      Series::new_by_SeriesData(
        serie.name,
        SeriesData::Int([serie.null_count()]),
      ),
    )
  }
  DataFrame::{ data, shape: [1, self.shape[1]], index: self.index }
}

///| Returns True if the DataFrame contains no rows.
pub fn DataFrame::is_empty(self : DataFrame) -> Bool {
  self.shape[0] == 0
}

///| Fill null values using the specified value or strategy
///
/// Parameters
///
/// - `self` : An instance of the DataFrame
/// - `value` : Value used to fill null values.
/// - `strategy` : Strategy used to fill null values. {'forward', 'backward', 'min', 'max', 'mean', 'zero', 'one'}
/// - `limit` : Number of consecutive null values to fill when using the ‘forward’ or ‘backward’ strategy.
///
/// Returns
///
/// - `DataFrame` : A new DataFrame with null values filled
/// 
/// Errors
/// 
/// - `InvalidType` : Raised if the value is not of the same type as the column
///
/// Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesInput::Int32_Nullable([Some(1), None, Some(3)])),
///   Series::new("B", SeriesInput::Int32_Nullable([None, Some(1), Some(3)])),
/// ])
/// let filled = df.fill_null!(value=SeriesValue::Int(2))
/// inspect!(filled.data[0].data, content="Int([1, 2, 3])")
/// let filled = df.fill_null!(strategy="forward")
/// inspect!(filled.data[0].data, content="Int([1, 1, 3])")
/// let filled = df.fill_null!(strategy="backward")
/// inspect!(filled.data[1].data, content="Int([1, 1, 3])")
/// let filled = df.fill_null!(strategy="max")
/// inspect!(filled.data[0].data, content="Int([1, 3, 3])")
/// let filled = df.fill_null!(strategy="mean")
/// inspect!(filled.data[0].data, content="Float([1, 2, 3])")
/// ```
pub fn DataFrame::fill_null(
  self : DataFrame,
  value? : SeriesValue,
  strategy? : String,
  limit? : Int
) -> DataFrame raise{
  let series = []
  for serie in self.data {
    series.push(serie.fill_null(value~, strategy~, limit~))
  }
  DataFrame::{ data: series, shape: self.shape, index: self.index }
}

///| Cast DataFrame column(s) to the specified dtype(s).
///
/// Parameters
///
/// - `self` : An instance of the DataFrame
/// - `data_type?` : The data type to cast the DataFrame to
/// - `cast_mapping?` : A mapping of column names to data types for casting specific columns
/// - `strict~` : Whether to enforce strict casting (default is true)
///
/// Returns
///
/// - `DataFrame` : A new DataFrame with the specified data type
///
/// Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesInput::Int32([1, 2, 3])),
///   Series::new("B", SeriesInput::Float32([1.1, 2.2, 3.3]))
/// ])
/// let df_cast = df.cast!(data_type = DataType::Float32)
/// inspect!(df_cast.data[0].data_type, content="Float32")
/// let df_cast = df.cast!(cast_mapping = {"A" : DataType::Float32, "B" : DataType::Int32})
/// inspect!(df_cast.data[0].data_type, content="Float32")
/// inspect!(df_cast.data[1].data_type, content="Int32")
/// ```
pub fn DataFrame::cast(
  self : DataFrame,
  data_type? : DataType,
  cast_mapping? : Map[String, DataType],
  strict~ : Bool = true
) -> DataFrame raise{
  match (data_type, cast_mapping) {
    (Some(data_type), _) => {
      let series = []
      for serie in self.data {
        series.push(serie.cast(data_type, strict~))
      }
      DataFrame::{ data: series, shape: self.shape, index: self.index }
    }
    (_, Some(cast_mapping)) => {
      let df = self.clone()
      for iter in cast_mapping {
        let (name, data_type) = iter
        let index = df.get_column_index(name)
        df.replace_column(index, df.data[index].cast(data_type, strict~))
      }
      df
    }
    _ => self.clone()
  }
}

///| Convert the DataFrame to a dictionary where the keys are column names and the values are Series
///
/// Returns
///
/// - `Map[String, Series]` : A dictionary representation of the DataFrame
///
/// Example
/// ```
/// let dict = df.to_dict()
/// ```
pub fn DataFrame::to_dict(self : DataFrame) -> Map[String, Series] {
  let dict = {}
  for series in self.data {
    dict[series.name] = series
  }
  dict
}

///| Convert DataFrame to instantiable string representation
///
/// Returns
///
/// - `String` : A string representation of the DataFrame that can be used to instantiate it
///
/// Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesInput::Int32([1, 2, 3])),
///   Series::new("C", SeriesInput::Str(["a", "b", "c"])),
/// ])
/// inspect!(df.to_init_repr(), content="DataFrame(\n\t[\n\t\tSeries 'A', [1, 2, 3], dtype=int32,\n\t\tSeries 'C', [\"a\", \"b\", \"c\"], dtype=string,\n\t]\n)")
/// ```
pub fn DataFrame::to_init_repr(self : DataFrame) -> String {
  let mut repr = "DataFrame(\n\t[\n"
  for series in self.data {
    repr += "\t\tSeries '\{series.name}', \{series.data.to_init_repr()}, dtype=\{series.data_type},\n"
  }
  repr += "\t]\n)"
  repr
}

///|
test "DataFrame::to_init_repr" {
  let df = DataFrame::new([
    Series::new("A", SeriesInput::Int32([1, 2, 3])),
    Series::new("C", SeriesInput::Str(["a", "b", "c"])),
  ])
  inspect(
    df.to_init_repr(),
    content="DataFrame(\n\t[\n\t\tSeries 'A', [1, 2, 3], dtype=Int32,\n\t\tSeries 'C', [\"a\", \"b\", \"c\"], dtype=String,\n\t]\n)",
  )
}

///| judge if the row/col in df has null value
fn DataFrame::has_nulls_rc(
  self : DataFrame,
  col? : Int,
  row? : Int,
  subset? : Array[String]
) -> Bool {
  match (col, row) {
    (None, None) => false
    (Some(col), None) | (Some(col), Some(_)) => self.data[col].has_null()
    (None, Some(row)) =>
      match subset {
        Some(subset) => {
          for col_name in subset {
            let serie : Series = (try? self.column(col_name)).unwrap()
            if serie.bitmap.bitmap[row] {
              return true
            }
          }
          false
        }
        None => {
          for series in self.data {
            if series.bitmap.bitmap[row] {
              return true
            }
          }
          false
        }
      }
  }
}

///| Drop all rows that contain null values
///
/// Parameters
///
/// - `self` : An instance of the DataFrame
/// - `subset~` : An optional array of column names to consider when dropping rows
///
/// Returns
///
/// - `DataFrame` : A new DataFrame with rows containing null values dropped
///
/// Errors
///
/// - `ColumnNotFoundError` : Raised if any of the specified columns in the subset are not found
///
/// Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesInput::Int32_Nullable([Some(1), None, Some(3)])),
///   Series::new("B", SeriesInput::Int32_Nullable([None, Some(1), Some(3)])),
/// ])
/// let df_dropped = df.drop_nulls!()
/// inspect!(df_dropped.data[0].data, content="Int([3])")
/// inspect!(df_dropped.data[1].data, content="Int([3])")
/// ```
pub fn DataFrame::drop_nulls(
  self : DataFrame,
  subset? : Array[String]
) -> DataFrame raise{
  let rows = []
  match subset {
    None =>
      for i in 0..<self.shape[0] {
        if not(self.has_nulls_rc(row=i)) {
          rows.push(i)
        }
      }
    Some(subset) => {
      guard subset.iter().all(fn(s) { self.index.contains(s) }) else {
        raise ColumnNotFoundError("Some column not found")
      }
      for i in 0..<self.shape[0] {
        if not(self.has_nulls_rc(row=i, subset~)) {
          rows.push(i)
        }
      }
    }
  }
  self.select_rows(indices=rows)
}

///|
test "DataFrame::drop_nulls" {
  let df = DataFrame::new([
    Series::new("A", SeriesInput::Int32_Nullable([Some(1), None, Some(3)])),
    Series::new("B", SeriesInput::Int32_Nullable([None, Some(1), Some(3)])),
  ])
  let df_dropped = df.drop_nulls()
  inspect(df_dropped.data[0].data, content="Int([3])")
  inspect(df_dropped.data[1].data, content="Int([3])")
}

///| Take every nth row in the DataFrame and return as a new DataFrame
///
/// Parameters
///
/// - `self` : An instance of the DataFrame
/// - `n` : The interval at which rows are selected
/// - `offset~` : The starting index for selection (default is 0)
///
/// Returns
///
/// - `DataFrame` : A new DataFrame containing every nth row
///
/// Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesInput::Int32([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])),
///   Series::new("B", SeriesInput::Int32([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])),
/// ])
/// let df_gathered = df.gather_every(2)
/// inspect!(df_gathered.data[0].data, content="Int([1, 3, 5, 7, 9])")
/// inspect!(df_gathered.data[1].data, content="Int([1, 3, 5, 7, 9])")
/// ```
pub fn DataFrame::gather_every(
  self : DataFrame,
  n : Int,
  offset~ : Int = 0
) -> DataFrame {
  let rows = []
  for i = offset; i < self.shape[0]; i = i + n {
    rows.push(i)
  }
  (try? self.select_rows(indices=rows)).unwrap()
}

///|
test "DataFrame::gather_every" {
  let df = DataFrame::new([
    Series::new("A", SeriesInput::Int32([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])),
    Series::new("B", SeriesInput::Int32([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])),
  ])
  let df_gathered = df.gather_every(2)
  inspect(df_gathered.data[0].data, content="Int([1, 3, 5, 7, 9])")
  inspect(df_gathered.data[1].data, content="Int([1, 3, 5, 7, 9])")
}

///| Drop a single column in-place and return the dropped column
///
/// Parameters
///
/// - `self` : An instance of the DataFrame
/// - `name` : The name of the column to be dropped
///
/// Returns
///
/// - `Series` : The dropped column
///
/// Errors
///
/// - `ColumnNotFoundError` : Raised if the specified column is not found
///
/// Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesInput::Int32([1, 2, 3])),
///   Series::new("B", SeriesInput::Int32([4, 5, 6])),
/// ])
/// let serie = df.drop_in_place!("A")
/// inspect!(serie.data, content="Int([1, 2, 3])")
/// inspect!(df.shape, content="[3, 1]")
/// ```
pub fn DataFrame::drop_in_place(self : DataFrame, name : String) -> Series raise {
  guard self.index.contains(name) else {
    raise ColumnNotFoundError("Column \{name} not found")
  }
  let serie_droped = self.data[(try? self.get_column_index(name)).unwrap()]
  self.drop_column(name)
  serie_droped
}

///|
test "DataFrame::drop_in_place" {
  let df = DataFrame::new([
    Series::new("A", SeriesInput::Int32([1, 2, 3])),
    Series::new("B", SeriesInput::Int32([4, 5, 6])),
  ])
  let serie = df.drop_in_place("A")
  inspect(serie.data, content="Int([1, 2, 3])")
  inspect(df.shape, content="[3, 1]")
}
